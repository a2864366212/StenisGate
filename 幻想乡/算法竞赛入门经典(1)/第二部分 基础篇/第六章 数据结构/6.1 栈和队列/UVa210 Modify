#include<iostream>
#include<deque>
#include<queue>
#include<map>
#include<cstring>
#include<vector>
#include<algorithm>
using namespace std;
struct Programs
{
	vector<string>step;
	int pos=0;
	int ID=-1;
};
queue<struct Programs>prevent;
deque<struct Programs>wait;

map<char,int>parameter_var;//共享全局变量模拟 
pair<map<char,int>::iterator,bool>insertJudge;
int lock_index=-1;
int judgeType(string&step)
{
	if(step.find("=")!=string::npos)
	{//var =constant
		return 0;
	}
	if(step.size()>=4&&step[0]=='p'&&step[4]=='t')
	{//print var
		return 1;
	}
	if(step=="lock")
	{//lock
		return 2;
	}
	if(step=="unlock")
	{//unlock
		return 3;
	}
	if(step=="end")
	{//end 
		return 4;
	}
}
void step1Fuc(string&s/*the string of step*/)
{//var = cons
	int result=0;
	int end1,begin2;
	for(int i=0;;i++)
	{
		if(s[i]=='=')
		{
			end1=i-2;
			begin2=i+2;
			break;
		}	
	}	
	char var= s[0];
	
	for(int i=begin2;i<s.size();i++)
	{
		result=result*10+ int(s[i]-'0');	
	}
	insertJudge=parameter_var.insert(make_pair(var,result));
	if(!insertJudge.second)
	{
		parameter_var[var]=result;
	}
	wait.front().pos++;
}
void step2Fuc(int ProgramID,string&s/*the string of step*/)
{
	cout<<ProgramID<<": ";
	//int subLength=s.size()-beginPos;
	//string parameter=s.substr(beginPos,subLength);
	char parameter=s[6];
	if(parameter_var.find(parameter)!=parameter_var.end())
	{
		cout<<parameter_var[parameter]<<endl;
	}
	wait.front().pos++;
}
bool step3FucBePrevent(int ProgramID)
{
	if(lock_index==-1)
	{
		lock_index=ProgramID-1;
		wait.front().pos++;
		return 0;
	}
	else{
		prevent.push(wait.front());
		
		if(!wait.empty())
		wait.pop_front();
		return 1;
	}
}
void step4Fuc()
{
	lock_index=-1;
	wait.front().pos++;
}
void step5Fuc()
{
	if(!wait.empty())
	wait.pop_front();
}

void QueueClear(queue<struct Programs>& q) {
   while(!q.empty())
   {
   		q.pop();
   } 
}

int main()
{
	int Group;
	
	int n;
	int Q;
	
	int t[5];
	
	cin>>Group;
	for(int g=0;g<Group;g++)
	{
		cin>>n>>Q;
		for(int i=0;i<5;i++)
		{
			cin>>t[i];
		}	
		getchar();
			
		string temp;
		
		for(int i=0;i<n;i++)
		{//load program
			struct Programs pgm;
			pgm.ID=i+1;
			while(1)
			{
				getline(cin,temp);
				
				pgm.step.push_back(temp);
				
				if(temp=="end")
				{
					break;
				}
			}
			wait.push_back(pgm);
		}
		while(!wait.empty())
		{
			int remainTime=Q;
			bool needPop = true;
			bool needPreventToWait=false;
			
			do
			{//for one program
				temp=wait.front().step[ wait.front().pos ];
				int type=judgeType(temp/*wait.front().step[ tempwait.front().pos ]*/);
				int ProgramID=wait.front().ID;
				remainTime-=t[type];
				type+=1;
				
				if(type==1)
				{
					step1Fuc( temp/*wait.front().step[ tempwait.front().pos ]*/);
					continue; 
				}
				if(type==2)
				{
					step2Fuc(ProgramID,temp/*wait.front().step[ tempwait.front().pos ]*/);
					continue; 
				}
				if(type==3)
				{
					if(step3FucBePrevent(ProgramID))
					{
						needPop=false;
					}
					continue; 
				}
				if(type==4)
				{
					step4Fuc();
					needPreventToWait=true;
					continue; 
				}
				if(type==5)
				{
					step5Fuc();
					continue; 
				}
			}while(remainTime>0&&!wait.empty());
			
			if(needPop) 
			{
				wait.push_back(wait.front());
				wait.pop_front();
			}
			if(needPreventToWait)
			{
				if(!prevent.empty())
				{
					wait.push_front(prevent.front());
					prevent.pop();
				}
			}	
		}
		parameter_var.erase(parameter_var.begin(),parameter_var.end());
		QueueClear(prevent);
		wait.clear();
		lock_index=-1;
		//renew all parameter		
	}
	return 0;
} 
/*
1

3 1 1 1 1 1 1
a = 4
print a
lock
b = 9
print b
unlock
print b
end
a = 3
print a
lock
b = 8
print b 
unlock
print b
end
b = 5
a = 17
print a
print b
lock
b = 21
print b
unlock
print b
end
*/
