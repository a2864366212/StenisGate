/*Programs executed concurrently on a uniprocessor system appear to be executed at the same time, but in reality the single CPU 
alternates between the programs, executing some number of instructions from each program before switching to the next. You are to 
simulate the concurrent execution of up to ten programs on such a system and determine the output that they will produce.
The program that is currently being executed is said to be running, while all programs awaiting execution are said to be ready. 
A program consists of a sequence of no more than 25 statements, one per line, followed by an end statement. The statements available 
are listed below.Each statement requires an integral number of time units to execute. The running program is permitted to continue 
executing instructions for a period of time called its quantum. When a programÕs time quantum expires, another ready program will 
be selected to run. Any instruction currently being executed when the time quantum expires will be allowed to complete.
Programs are queued first-in-first-out for execution in a ready queue. The initial order of the ready queue corresponds to the original
order of the programs in the input file. This order can change, however, as a result of the execution of lock and unlock statements.
The lock and unlock statements are used whenever a program wishes to claim mutually exclusive access to the variables it is manipulating.
These statements always occur in pairs, bracketing one or more other statements. A lock will always precede an unlock, and these
statements will never be nested. Once a program successfully executes a lock statement, no other program may successfully execute a 
lock statement until the locking program runs and executes the corresponding unlock statement. Should a running program attempt to 
execute a lock while one is already in effect, this program will be placed at the end of the blocked queue. Programs blocked in this
fashion lose any of their current time quantum remaining. When an unlock is executed, any program at the head of the blocked queue is
moved to the head of the ready queue. The first statement this program will execute when it runs will be the lock statement that 
previously failed. Note that it is up to the programs involved to enforce the mutual exclusion protocol through correct usage of lock
andunlock statements. (A renegade program with no lock/unlock pair could alter any variables it wished, despite the proper use
oflock/unlock by the other programs.)

Input
The input begins with a single positive integer on a line by itself indicating the number of the cases following, each of them as 
described below. This line is followed by a blank line, and there is also a blank line between two consecutive inputs.
The first line of the input file consists of seven integers separated by spaces. These integers specify (in order): the number of
programs which follow, the unit execution times for each of the five statements (in the order given above), and the number of time
units comprising the time quantum. The remainder of the input consists of the programs, which are correctly formed from statements
according to the rules described above.
All program statements begin in the first column of a line. Blanks appearing in a statement should be ignored. Associated with each
program is an identification number based upon its location in the input data (the first program has ID = 1, the second has ID = 2, etc.)
Output
For each test case, the output must follow the description below. The outputs of two consecutive cases will be separated by a blank line.
Your output will contain of the output generated by the print statements as they occur during the simulation. When a print statement is executed,
your program should display the program ID, a colon, a space, and the value of the selected variable. Output from separate print
statements should appear on separate lines.
A sample input and correct output are shown below.

Sample Input
1

3 1 1 1 1 1 1
a = 4
print a
lock
b = 9
print b
unlock
print b
end
a = 3
print a
lock
b = 8
print b 
unlock
print b
end
b = 5
a = 17
print a
print b
lock
b = 21
print b
unlock
print b
end
Sample Output
1: 3
2: 3
3: 17
3: 9
1: 9
1: 9
2: 8
2: 8
3: 21
3: 21
*/
//code begin 6-1并行程序模拟 双端队列
#include<iostream>
#include<deque>
#include<queue>
#include<map>
#include<cstring>
#include<vector>
#include<algorithm>
using namespace std;
struct Programs
{
	vector<string>step;
	int pos=0;
	int ID=-1;
};
queue<struct Programs>prevent;
deque<struct Programs>wait;

map<string,int>parameter_var;//¹²ÏíÈ«¾Ö±äÁ¿Ä£Äâ 
pair<map<string,int>::iterator,bool>insertJudge;
int lock_index=-1;
int judgeType(string&step)
{
	if(step.find("=")!=string::npos)
	{//var =constant
		return 0;
	}
	if(step.size()>=4&&step[0]=='p'&&step[4]=='t')
	{//print var
		return 1;
	}
	if(step=="lock")
	{//lock
		return 2;
	}
	if(step=="unlock")
	{//unlock
		return 3;
	}
	if(step=="end")
	{//end 
		return 4;
	}
}
void step1Fuc(string&s/*the string of step*/)
{//var = cons
	int result=0;
	int end1,begin2;
	for(int i=0;;i++)
	{
		if(s[i]=='=')
		{
			end1=i-2;
			begin2=i+2;
			break;
		}	
	}	
	string var= s.substr(0,end1+1);
	
	for(int i=begin2;i<s.size();i++)
	{
		result=result*10+ int(s[i]-'0');	
	}
	insertJudge=parameter_var.insert(make_pair(var,result));
	if(!insertJudge.second)
	{
		parameter_var[var]=result;
	}
}
void step2Fuc(int ProgramID,string&s/*the string of step*/)
{
	int beginPos;
	cout<<ProgramID<<": ";
	for(int i=s.size()-1;;i--)
	{
		if(s[i]==' ')
		{
			beginPos=i+1;
		}
	}
	string parameter=s.substr(beginPos,s.size()-beginPos);
	if(parameter_var.find(parameter)!=parameter_var.end())
	{
		cout<<parameter_var[parameter]<<endl;
	}
}
bool step3FucBePrevent(int ProgramID)
{
	if(lock_index==-1)
	{
		lock_index=ProgramID-1;
		return 0;
	}
	else{
		prevent.push(wait.front());
		wait.pop_front();
		return 1;
	}
}
void step4Fuc()
{
	lock_index=-1;
}
void step5Fuc()
{
	wait.pop_front();
	
}
queue<struct Programs>empty;
void QueueClear(queue<struct Programs>& q) {
    swap(empty, q);
}

int main()
{
	int Group;
	
	int n;
	int Q;
	
	int t[5];
	
	cin>>Group;
	for(int g=0;g<Group;g++)
	{
		cin>>n>>Q;
		for(int i=0;i<5;i++)
		{
			cin>>t[i];
		}	
		getchar();
			
		string temp;
		
		for(int i=0;i<n;i++)
		{//load program
			struct Programs pgm;
			pgm.ID=i+1;
			while(1)
			{
				getline(cin,temp);
				
				pgm.step.push_back(temp);
				
				if(temp=="end")
				{
					break;
				}
			}
			wait.push_back(pgm);
		}
		while(!wait.empty())
		{
			int remainTime=Q;
			bool needPop = true;
			bool needPreventToWait=false;
			
			do
			{//for one program
				int type=judgeType(wait.front().step[ wait.front().pos ]);
				int ProgramID=wait.front().ID;
				remainTime-=t[type];
				type+=1;
				
				if(type==1)
				{
					step1Fuc( wait.front().step[ wait.front().pos ] );
				}
				if(type==2)
				{
					step2Fuc(ProgramID,wait.front().step[ wait.front().pos ] /*the string of step*/);
				}
				if(type==3)
				{
					if(step3FucBePrevent(ProgramID))
					{
						needPop=false;
					}
				}
				if(type==4)
				{
					step4Fuc();
				}
				if(type==5)
				{
					step5Fuc();
				}
			}while(remainTime>0);
			
			if(needPop) 
			{
				wait.push_back(wait.front());
				wait.pop_front();
			}
			if(needPreventToWait)
			{
				wait.push_front(prevent.front());
				prevent.pop();
			}	
		}
		
		parameter_var.erase(parameter_var.begin(),parameter_var.end());
		QueueClear(prevent);
		wait.clear();
		lock_index=-1;
		//renew all parameter		
	}
	return 0;
} 
